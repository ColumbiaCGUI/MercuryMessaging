// This file is automatically generated by a script based on the CommandBuilder API.
// This file adds additional overloads to the CommandBuilder API with convenience parameters like colors.
using Unity.Burst;
using UnityEngine;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Mathematics;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace Drawing {
	public partial struct CommandBuilder {
		/// <summary>\copydocref{Line(float3,float3)}</summary>
		public void Line (float3 a, float3 b, Color color) {
			Reserve<Color32, LineData>();
			Add(Command.Line | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new LineData { a = a, b = b });
		}
		/// <summary>\copydocref{Ray(float3,float3)}</summary>
		public void Ray (float3 origin, float3 direction, Color color) {
			Line(origin, origin + direction, color);
		}
		/// <summary>\copydocref{Ray(Ray,float)}</summary>
		public void Ray (Ray ray, float length, Color color) {
			Line(ray.origin, ray.origin + ray.direction * length, color);
		}
		/// <summary>\copydocref{Arc(float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void Arc (float3 center, float3 start, float3 end, Color color) {
			PushColor(color);
			var d1 = start - center;
			var d2 = end - center;
			var normal = math.cross(d2, d1);

			if (math.any(normal != 0) && math.all(math.isfinite(normal))) {
				var m = Matrix4x4.TRS(center, Quaternion.LookRotation(d1, normal), Vector3.one);
				var angle = Vector3.SignedAngle(d1, d2, normal) * Mathf.Deg2Rad;
				PushMatrix(m);
				CircleXZInternal(float3.zero, math.length(d1), 90 * Mathf.Deg2Rad, 90 * Mathf.Deg2Rad - angle);
				PopMatrix();
			}
			PopColor();
		}
		/// <summary>\copydocref{CircleXZ(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xz.Circle instead")]
		public void CircleXZ (float3 center, float radius, float startAngle, float endAngle, Color color) {
			CircleXZInternal(center, radius, startAngle, endAngle, color);
		}
		/// <summary>\copydocref{CircleXZ(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xz.Circle instead")]
		public void CircleXZ (float3 center, float radius, Color color) {
			CircleXZ(center, radius, 0f, 2 * Mathf.PI, color);
		}
		/// <summary>\copydocref{CircleXY(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xy.Circle instead")]
		public void CircleXY (float3 center, float radius, float startAngle, float endAngle, Color color) {
			PushColor(color);
			PushMatrix(XZtoXYPlaneMatrix);
			CircleXZ(new float3(center.x, -center.z, center.y), radius, startAngle, endAngle);
			PopMatrix();
			PopColor();
		}

		/// <summary>\copydocref{CircleXY(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xy.Circle instead")]
		public void CircleXY (float3 center, float radius, Color color) {
			CircleXY(center, radius, 0f, 2 * Mathf.PI, color);
		}

		/// <summary>\copydocref{Circle(float3,float3,float)}</summary>
		public void Circle (float3 center, float3 normal, float radius, Color color) {
			Reserve<Color32, CircleData>();
			Add(Command.Circle | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new CircleData { center = center, normal = normal, radius = radius });
		}
		/// <summary>\copydocref{SolidArc(float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidArc (float3 center, float3 start, float3 end, Color color) {
			PushColor(color);
			var d1 = start - center;
			var d2 = end - center;
			var normal = math.cross(d2, d1);

			if (math.any(normal)) {
				var m = Matrix4x4.TRS(center, Quaternion.LookRotation(d1, normal), Vector3.one);
				var angle = Vector3.SignedAngle(d1, d2, normal) * Mathf.Deg2Rad;
				PushMatrix(m);
				SolidCircleXZInternal(float3.zero, math.length(d1), 90 * Mathf.Deg2Rad, 90 * Mathf.Deg2Rad - angle);
				PopMatrix();
			}
			PopColor();
		}

		/// <summary>\copydocref{SolidCircleXZ(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xz.SolidCircle instead")]
		public void SolidCircleXZ (float3 center, float radius, float startAngle, float endAngle, Color color) {
			SolidCircleXZInternal(center, radius, startAngle, endAngle, color);
		}

		/// <summary>\copydocref{SolidCircleXZ(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xz.SolidCircle instead")]
		public void SolidCircleXZ (float3 center, float radius, Color color) {
			SolidCircleXZ(center, radius, 0f, 2 * Mathf.PI, color);
		}

		/// <summary>\copydocref{SolidCircleXY(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xy.SolidCircle instead")]
		public void SolidCircleXY (float3 center, float radius, float startAngle, float endAngle, Color color) {
			PushColor(color);
			PushMatrix(XZtoXYPlaneMatrix);
			SolidCircleXZInternal(new float3(center.x, -center.z, center.y), radius, startAngle, endAngle);
			PopMatrix();
			PopColor();
		}

		/// <summary>\copydocref{SolidCircleXY(float3,float,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		[System.Obsolete("Use Draw.xy.SolidCircle instead")]
		public void SolidCircleXY (float3 center, float radius, Color color) {
			SolidCircleXY(center, radius, 0f, 2 * Mathf.PI, color);
		}

		/// <summary>\copydocref{SolidCircle(float3,float3,float)}</summary>
		public void SolidCircle (float3 center, float3 normal, float radius, Color color) {
			Reserve<Color32, CircleData>();
			Add(Command.Disc | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new CircleData { center = center, normal = normal, radius = radius });
		}

		/// <summary>\copydocref{SphereOutline(float3,float)}</summary>
		public void SphereOutline (float3 center, float radius, Color color) {
			Reserve<Color32, SphereData>();
			Add(Command.SphereOutline | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new SphereData { center = center, radius = radius });
		}

		/// <summary>\copydocref{WireCylinder(float3,float3,float)}</summary>
		public void WireCylinder (float3 bottom, float3 top, float radius, Color color) {
			WireCylinder(bottom, top - bottom, math.length(top - bottom), radius, color);
		}
		/// <summary>\copydocref{WireCylinder(float3,float3,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireCylinder (float3 position, float3 up, float height, float radius, Color color) {
			up = math.normalizesafe(up);
			if (math.all(up == 0) || math.any(math.isnan(up)) || math.isnan(height) || math.isnan(radius)) return;
			PushColor(color);

			OrthonormalBasis(up, out var basis1, out var basis2);

			PushMatrix(new float4x4(
				new float4(basis1 * radius, 0),
				new float4(up * height, 0),
				new float4(basis2 * radius, 0),
				new float4(position, 1)
				));

			CircleXZInternal(float3.zero, 1);
			if (height > 0) {
				CircleXZInternal(new float3(0, 1, 0), 1);
				Line(new float3(1, 0, 0), new float3(1, 1, 0));
				Line(new float3(-1, 0, 0), new float3(-1, 1, 0));
				Line(new float3(0, 0, 1), new float3(0, 1, 1));
				Line(new float3(0, 0, -1), new float3(0, 1, -1));
			}
			PopMatrix();
			PopColor();
		}
		/// <summary>\copydocref{WireCapsule(float3,float3,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireCapsule (float3 start, float3 end, float radius, Color color) {
			PushColor(color);
			var dir = end - start;
			var length = math.length(dir);

			if (length < 0.0001) {
				// The endpoints are the same, we can't draw a capsule from this because we don't know its orientation.
				// Draw a sphere as a fallback
				WireSphere(start, radius);
			} else {
				var normalized_dir = dir / length;

				WireCapsule(start - normalized_dir*radius, normalized_dir, length + 2*radius, radius);
			}
			PopColor();
		}
		/// <summary>\copydocref{WireCapsule(float3,float3,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireCapsule (float3 position, float3 direction, float length, float radius, Color color) {
			direction = math.normalizesafe(direction);
			if (math.all(direction == 0) || math.any(math.isnan(direction)) || math.isnan(length) || math.isnan(radius)) return;
			PushColor(color);

			if (radius <= 0) {
				Line(position, position + direction * length);
			} else {
				length = math.max(length, radius*2);
				OrthonormalBasis(direction, out var basis1, out var basis2);

				PushMatrix(new float4x4(
					new float4(basis1, 0),
					new float4(direction, 0),
					new float4(basis2, 0),
					new float4(position, 1)
					));
				CircleXZInternal(new float3(0, radius, 0), radius);
				PushMatrix(XZtoXYPlaneMatrix);
				CircleXZInternal(new float3(0, 0, radius), radius, Mathf.PI, 2 * Mathf.PI);
				PopMatrix();
				PushMatrix(XZtoYZPlaneMatrix);
				CircleXZInternal(new float3(radius, 0, 0), radius, Mathf.PI*0.5f, Mathf.PI*1.5f);
				PopMatrix();
				if (length > 0) {
					var upperY = length - radius;
					var lowerY = radius;
					CircleXZInternal(new float3(0, upperY, 0), radius);
					PushMatrix(XZtoXYPlaneMatrix);
					CircleXZInternal(new float3(0, 0, upperY), radius, 0, Mathf.PI);
					PopMatrix();
					PushMatrix(XZtoYZPlaneMatrix);
					CircleXZInternal(new float3(upperY, 0, 0), radius, -Mathf.PI*0.5f, Mathf.PI*0.5f);
					PopMatrix();
					Line(new float3(radius, lowerY, 0), new float3(radius, upperY, 0));
					Line(new float3(-radius, lowerY, 0), new float3(-radius, upperY, 0));
					Line(new float3(0, lowerY, radius), new float3(0, upperY, radius));
					Line(new float3(0, lowerY, -radius), new float3(0, upperY, -radius));
				}
				PopMatrix();
			}
			PopColor();
		}
		/// <summary>\copydocref{WireSphere(float3,float)}</summary>
		public void WireSphere (float3 position, float radius, Color color) {
			PushColor(color);
			SphereOutline(position, radius);
			Circle(position, new float3(1, 0, 0), radius);
			Circle(position, new float3(0, 1, 0), radius);
			Circle(position, new float3(0, 0, 1), radius);
			PopColor();
		}
		/// <summary>\copydocref{Polyline(List&lt;Vector3&gt;,bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (List<Vector3> points, bool cycle, Color color) {
			PushColor(color);
			for (int i = 0; i < points.Count - 1; i++) {
				Line(points[i], points[i+1]);
			}
			if (cycle && points.Count > 1) Line(points[points.Count - 1], points[0]);
			PopColor();
		}
		/// <summary>\copydocref{Polyline(List&lt;Vector3&gt;,bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (List<Vector3> points, Color color) {
			Polyline(points, false, color);
		}
		/// <summary>\copydocref{Polyline(Vector3[],bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (Vector3[] points, bool cycle, Color color) {
			PushColor(color);
			for (int i = 0; i < points.Length - 1; i++) {
				Line(points[i], points[i+1]);
			}
			if (cycle && points.Length > 1) Line(points[points.Length - 1], points[0]);
			PopColor();
		}
		/// <summary>\copydocref{Polyline(Vector3[],bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (Vector3[] points, Color color) {
			Polyline(points, false, color);
		}
		/// <summary>\copydocref{Polyline(float3[],bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (float3[] points, bool cycle, Color color) {
			PushColor(color);
			for (int i = 0; i < points.Length - 1; i++) {
				Line(points[i], points[i+1]);
			}
			if (cycle && points.Length > 1) Line(points[points.Length - 1], points[0]);
			PopColor();
		}
		/// <summary>\copydocref{Polyline(float3[],bool)}</summary>
		/// <param name="color">Color of the object</param>
		[BurstDiscard]
		public void Polyline (float3[] points, Color color) {
			Polyline(points, false, color);
		}
		/// <summary>\copydocref{Polyline(NativeArray&lt;float3&gt;,bool)}</summary>
		/// <param name="color">Color of the object</param>
		public void Polyline (NativeArray<float3> points, bool cycle, Color color) {
			PushColor(color);
			for (int i = 0; i < points.Length - 1; i++) {
				Line(points[i], points[i+1]);
			}
			if (cycle && points.Length > 1) Line(points[points.Length - 1], points[0]);
			PopColor();
		}
		/// <summary>\copydocref{Polyline(NativeArray&lt;float3&gt;,bool)}</summary>
		/// <param name="color">Color of the object</param>
		public void Polyline (NativeArray<float3> points, Color color) {
			Polyline(points, false, color);
		}
		/// <summary>\copydocref{DashedLine(float3,float3,float,float)}</summary>
		public void DashedLine (float3 a, float3 b, float dash, float gap, Color color) {
			PushColor(color);
			var p = new PolylineWithSymbol(SymbolDecoration.None, gap, 0, dash + gap);
			p.MoveTo(ref this, a);
			p.MoveTo(ref this, b);
			PopColor();
		}

		/// <summary>\copydocref{DashedPolyline(List&lt;Vector3&gt;,float,float)}</summary>
		public void DashedPolyline (List<Vector3> points, float dash, float gap, Color color) {
			PushColor(color);
			var p = new PolylineWithSymbol(SymbolDecoration.None, gap, 0, dash + gap);
			for (int i = 0; i < points.Count; i++) {
				p.MoveTo(ref this, points[i]);
			}
			PopColor();
		}

		/// <summary>\copydocref{WireBox(float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireBox (float3 center, float3 size, Color color) {
			Reserve<Color32, BoxData>();
			Add(Command.WireBox | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new BoxData { center = center, size = size });
		}
		/// <summary>\copydocref{WireBox(float3,quaternion,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireBox (float3 center, quaternion rotation, float3 size, Color color) {
			PushColor(color);
			PushMatrix(float4x4.TRS(center, rotation, size));
			WireBox(float3.zero, new float3(1, 1, 1));
			PopMatrix();
			PopColor();
		}
		/// <summary>\copydocref{WireBox(Bounds)}</summary>
		public void WireBox (Bounds bounds, Color color) {
			WireBox(bounds.center, bounds.size, color);
		}
		/// <summary>\copydocref{WireMesh(Mesh)}</summary>
		public void WireMesh (Mesh mesh, Color color) {
#if UNITY_2020_1_OR_NEWER
			if (mesh == null) throw new System.ArgumentNullException();
			PushColor(color);

			// Use a burst compiled function to draw the lines
			// This is significantly faster than pure C# (about 5x).
			var meshDataArray = Mesh.AcquireReadOnlyMeshData(mesh);
			var meshData = meshDataArray[0];

			JobWireMesh.JobWireMeshFunctionPointer(ref meshData, ref this);
			meshDataArray.Dispose();
#else
			Debug.LogError("The WireMesh method is only suppored in Unity 2020.1 or later");
#endif
			PopColor();
		}
		/// <summary>\copydocref{WireMesh(NativeArray&lt;float3&gt;,NativeArray&lt;int&gt;)}</summary>
		public void WireMesh (NativeArray<float3> vertices, NativeArray<int> triangles, Color color) {
			PushColor(color);
#if UNITY_2020_1_OR_NEWER
			unsafe {
				JobWireMesh.WireMesh((float3*)vertices.GetUnsafeReadOnlyPtr(), (int*)triangles.GetUnsafeReadOnlyPtr(), vertices.Length, triangles.Length, ref this);
			}
#else
			Debug.LogError("The WireMesh method is only suppored in Unity 2020.1 or later");
#endif
			PopColor();
		}
		/// <summary>\copydocref{SolidMesh(Mesh)}</summary>
		public void SolidMesh (Mesh mesh, Color color) {
			SolidMeshInternal(mesh, false, color);
		}

		/// <summary>\copydocref{Cross(float3,float)}</summary>
		public void Cross (float3 position, float size, Color color) {
			PushColor(color);
			size *= 0.5f;
			Line(position - new float3(size, 0, 0), position + new float3(size, 0, 0));
			Line(position - new float3(0, size, 0), position + new float3(0, size, 0));
			Line(position - new float3(0, 0, size), position + new float3(0, 0, size));
			PopColor();
		}
		/// <summary>\copydocref{Cross(float3,float)}</summary>
		public void Cross (float3 position, Color color) {
			Cross(position, 1, color);
		}
		/// <summary>\copydocref{CrossXZ(float3,float)}</summary>
		[System.Obsolete("Use Draw.xz.Cross instead")]
		public void CrossXZ (float3 position, float size, Color color) {
			PushColor(color);
			size *= 0.5f;
			Line(position - new float3(size, 0, 0), position + new float3(size, 0, 0));
			Line(position - new float3(0, 0, size), position + new float3(0, 0, size));
			PopColor();
		}
		/// <summary>\copydocref{CrossXZ(float3,float)}</summary>
		[System.Obsolete("Use Draw.xz.Cross instead")]
		public void CrossXZ (float3 position, Color color) {
			CrossXZ(position, 1, color);
		}
		/// <summary>\copydocref{CrossXY(float3,float)}</summary>
		[System.Obsolete("Use Draw.xy.Cross instead")]
		public void CrossXY (float3 position, float size, Color color) {
			PushColor(color);
			size *= 0.5f;
			Line(position - new float3(size, 0, 0), position + new float3(size, 0, 0));
			Line(position - new float3(0, size, 0), position + new float3(0, size, 0));
			PopColor();
		}
		/// <summary>\copydocref{CrossXY(float3,float)}</summary>
		[System.Obsolete("Use Draw.xy.Cross instead")]
		public void CrossXY (float3 position, Color color) {
			CrossXY(position, 1, color);
		}
		/// <summary>\copydocref{Bezier(float3,float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void Bezier (float3 p0, float3 p1, float3 p2, float3 p3, Color color) {
			PushColor(color);
			float3 prev = p0;

			for (int i = 1; i <= 20; i++) {
				float t = i/20.0f;
				float3 p = EvaluateCubicBezier(p0, p1, p2, p3, t);
				Line(prev, p);
				prev = p;
			}
			PopColor();
		}
		/// <summary>\copydocref{CatmullRom(List&lt;Vector3&gt;)}</summary>
		/// <param name="color">Color of the object</param>
		public void CatmullRom (List<Vector3> points, Color color) {
			if (points.Count < 2) return;
			PushColor(color);

			if (points.Count == 2) {
				Line(points[0], points[1]);
			} else {
				// count >= 3
				var count = points.Count;
				// Draw first curve, this is special because the first two control points are the same
				CatmullRom(points[0], points[0], points[1], points[2]);
				for (int i = 0; i + 3 < count; i++) {
					CatmullRom(points[i], points[i+1], points[i+2], points[i+3]);
				}
				// Draw last curve
				CatmullRom(points[count-3], points[count-2], points[count-1], points[count-1]);
			}
			PopColor();
		}

		/// <summary>\copydocref{CatmullRom(float3,float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void CatmullRom (float3 p0, float3 p1, float3 p2, float3 p3, Color color) {
			PushColor(color);
			// References used:
			// p.266 GemsV1
			//
			// tension is often set to 0.5 but you can use any reasonable value:
			// http://www.cs.cmu.edu/~462/projects/assn2/assn2/catmullRom.pdf
			//
			// bias and tension controls:
			// http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/interpolation/

			// We will convert the catmull rom spline to a bezier curve for simplicity.
			// The end result of this will be a conversion matrix where we transform catmull rom control points
			// into the equivalent bezier curve control points.

			// Conversion matrix
			// =================

			// A centripetal catmull rom spline can be separated into the following terms:
			// 1 * p1 +
			// t * (-0.5 * p0 + 0.5*p2) +
			// t*t * (p0 - 2.5*p1  + 2.0*p2 + 0.5*t2) +
			// t*t*t * (-0.5*p0 + 1.5*p1 - 1.5*p2 + 0.5*p3)
			//
			// Matrix form:
			// 1     t   t^2 t^3
			// {0, -1/2, 1, -1/2}
			// {1, 0, -5/2, 3/2}
			// {0, 1/2, 2, -3/2}
			// {0, 0, -1/2, 1/2}

			// Transposed matrix:
			// M_1 = {{0, 1, 0, 0}, {-1/2, 0, 1/2, 0}, {1, -5/2, 2, -1/2}, {-1/2, 3/2, -3/2, 1/2}}

			// A bezier spline can be separated into the following terms:
			// (-t^3 + 3 t^2 - 3 t + 1) * c0 +
			// (3t^3 - 6*t^2 + 3t) * c1 +
			// (3t^2 - 3t^3) * c2 +
			// t^3 * c3
			//
			// Matrix form:
			// 1  t  t^2  t^3
			// {1, -3, 3, -1}
			// {0, 3, -6, 3}
			// {0, 0, 3, -3}
			// {0, 0, 0, 1}

			// Transposed matrix:
			// M_2 = {{1, 0, 0, 0}, {-3, 3, 0, 0}, {3, -6, 3, 0}, {-1, 3, -3, 1}}

			// Thus a bezier curve can be evaluated using the expression
			// output1 = T * M_1 * c
			// where T = [1, t, t^2, t^3] and c being the control points c = [c0, c1, c2, c3]^T
			//
			// and a catmull rom spline can be evaluated using
			//
			// output2 = T * M_2 * p
			// where T = same as before and p = [p0, p1, p2, p3]^T
			//
			// We can solve for c in output1 = output2
			// T * M_1 * c = T * M_2 * p
			// M_1 * c = M_2 * p
			// c = M_1^(-1) * M_2 * p
			// Thus a conversion matrix from p to c is M_1^(-1) * M_2
			// This can be calculated and the result is the following matrix:
			//
			// {0, 1, 0, 0}
			// {-1/6, 1, 1/6, 0}
			// {0, 1/6, 1, -1/6}
			// {0, 0, 1, 0}
			// ------------------------------------------------------------------
			//
			// Using this we can calculate c = M_1^(-1) * M_2 * p
			var c0 = p1;
			var c1 = (-p0 + 6*p1 + 1*p2)*(1/6.0f);
			var c2 = (p1 + 6*p2 - p3)*(1/6.0f);
			var c3 = p2;

			// And finally draw the bezier curve which is equivalent to the desired catmull-rom spline
			Bezier(c0, c1, c2, c3);
			PopColor();
		}

		/// <summary>\copydocref{Arrow(float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void Arrow (float3 from, float3 to, Color color) {
			ArrowRelativeSizeHead(from, to, DEFAULT_UP, 0.2f, color);
		}
		/// <summary>\copydocref{Arrow(float3,float3,float3,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Arrow (float3 from, float3 to, float3 up, float headSize, Color color) {
			PushColor(color);
			var length_sq = math.lengthsq(to - from);

			if (length_sq > 0.000001f) {
				ArrowRelativeSizeHead(from, to, up, headSize * math.rsqrt(length_sq));
			}
			PopColor();
		}
		/// <summary>\copydocref{ArrowRelativeSizeHead(float3,float3,float3,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void ArrowRelativeSizeHead (float3 from, float3 to, float3 up, float headFraction, Color color) {
			PushColor(color);
			Line(from, to);
			var dir = to - from;

			var normal = math.cross(dir, up);
			// Pick a different up direction if the direction happened to be colinear with that one.
			if (math.all(normal == 0)) normal = math.cross(new float3(1, 0, 0), dir);
			// Pick a different up direction if up=(1,0,0) and thus the above check would have generated a zero vector again
			if (math.all(normal == 0)) normal = math.cross(new float3(0, 1, 0), dir);
			normal = math.normalizesafe(normal) * math.length(dir);

			Line(to, to - (dir + normal) * headFraction);
			Line(to, to - (dir - normal) * headFraction);
			PopColor();
		}
		/// <summary>\copydocref{Arrowhead(float3,float3,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Arrowhead (float3 center, float3 direction, float radius, Color color) {
			Arrowhead(center, direction, DEFAULT_UP, radius, color);
		}

		/// <summary>\copydocref{Arrowhead(float3,float3,float3,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Arrowhead (float3 center, float3 direction, float3 up, float radius, Color color) {
			if (math.all(direction == 0)) return;
			PushColor(color);
			direction = math.normalizesafe(direction);
			var normal = math.cross(direction, up);
			const float SinPiOver3 = 0.866025f;
			const float CosPiOver3 = 0.5f;
			var circleCenter = center - radius * (1 - CosPiOver3)*0.5f * direction;
			var p1 = circleCenter + radius * direction;
			var p2 = circleCenter - radius * CosPiOver3 * direction + radius * SinPiOver3 * normal;
			var p3 = circleCenter - radius * CosPiOver3 * direction - radius * SinPiOver3 * normal;
			Line(p1, p2);
			Line(p2, circleCenter);
			Line(circleCenter, p3);
			Line(p3, p1);
			PopColor();
		}

		/// <summary>\copydocref{ArrowheadArc(float3,float3,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void ArrowheadArc (float3 origin, float3 direction, float offset, float width, Color color) {
			if (!math.any(direction)) return;
			if (offset < 0) throw new System.ArgumentOutOfRangeException(nameof(offset));
			if (offset == 0) return;
			PushColor(color);

			var rot = Quaternion.LookRotation(direction, DEFAULT_UP);
			PushMatrix(Matrix4x4.TRS(origin, rot, Vector3.one));
			var a1 = math.PI * 0.5f - width * (0.5f * Mathf.Deg2Rad);
			var a2 = math.PI * 0.5f + width * (0.5f * Mathf.Deg2Rad);
			CircleXZInternal(float3.zero, offset, a1, a2);
			var p1 = new float3(math.cos(a1), 0, math.sin(a1)) * offset;
			var p2 = new float3(math.cos(a2), 0, math.sin(a2)) * offset;
			const float sqrt2 = 1.4142f;
			var p3 = new float3(0, 0, sqrt2 * offset);
			Line(p1, p3);
			Line(p3, p2);
			PopMatrix();
			PopColor();
		}
		/// <summary>\copydocref{ArrowheadArc(float3,float3,float,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void ArrowheadArc (float3 origin, float3 direction, float offset, Color color) {
			ArrowheadArc(origin, direction, offset, 60, color);
		}
		/// <summary>\copydocref{WireGrid(float3,quaternion,int2,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireGrid (float3 center, quaternion rotation, int2 cells, float2 totalSize, Color color) {
			PushColor(color);
			cells = math.max(cells, new int2(1, 1));
			PushMatrix(float4x4.TRS(center, rotation, new Vector3(totalSize.x, 0, totalSize.y)));
			int w = cells.x;
			int h = cells.y;
			for (int i = 0; i <= w; i++) Line(new float3(i/(float)w - 0.5f, 0, -0.5f), new float3(i/(float)w - 0.5f, 0, 0.5f));
			for (int i = 0; i <= h; i++) Line(new float3(-0.5f, 0, i/(float)h - 0.5f), new float3(0.5f, 0, i/(float)h - 0.5f));
			PopMatrix();
			PopColor();
		}
		/// <summary>\copydocref{WireTriangle(float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireTriangle (float3 a, float3 b, float3 c, Color color) {
			PushColor(color);
			Line(a, b);
			Line(b, c);
			Line(c, a);
			PopColor();
		}

		/// <summary>\copydocref{WireRectangleXZ(float3,float2)}</summary>
		[System.Obsolete("Use Draw.xz.WireRectangle instead")]
		public void WireRectangleXZ (float3 center, float2 size, Color color) {
			WireRectangle(center, quaternion.identity, size, color);
		}

		/// <summary>\copydocref{WireRectangle(float3,quaternion,float2)}</summary>
		public void WireRectangle (float3 center, quaternion rotation, float2 size, Color color) {
			WirePlane(center, rotation, size, color);
		}
		/// <summary>\copydocref{WireRectangle(Rect)}</summary>
		[System.Obsolete("Use Draw.xy.WireRectangle instead")]
		public void WireRectangle (Rect rect, Color color) {
			xy.WireRectangle(rect, color);
		}
		/// <summary>\copydocref{WireTriangle(float3,quaternion,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireTriangle (float3 center, quaternion rotation, float radius, Color color) {
			WirePolygon(center, 3, rotation, radius, color);
		}

		/// <summary>\copydocref{WirePentagon(float3,quaternion,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WirePentagon (float3 center, quaternion rotation, float radius, Color color) {
			WirePolygon(center, 5, rotation, radius, color);
		}

		/// <summary>\copydocref{WireHexagon(float3,quaternion,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WireHexagon (float3 center, quaternion rotation, float radius, Color color) {
			WirePolygon(center, 6, rotation, radius, color);
		}

		/// <summary>\copydocref{WirePolygon(float3,int,quaternion,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void WirePolygon (float3 center, int vertices, quaternion rotation, float radius, Color color) {
			PushColor(color);
			PushMatrix(float4x4.TRS(center, rotation, new float3(radius, radius, radius)));
			float3 prev = new float3(0, 0, 1);
			for (int i = 1; i <= vertices; i++) {
				float a = 2 * math.PI * (i / (float)vertices);
				var p = new float3(math.sin(a), 0, math.cos(a));
				Line(prev, p);
				prev = p;
			}
			PopMatrix();
			PopColor();
		}

		/// <summary>\copydocref{SolidRectangle(Rect)}</summary>
		[System.Obsolete("Use Draw.xy.SolidRectangle instead")]
		public void SolidRectangle (Rect rect, Color color) {
			xy.SolidRectangle(rect, color);
		}

		/// <summary>\copydocref{SolidPlane(float3,float3,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidPlane (float3 center, float3 normal, float2 size, Color color) {
			PushColor(color);
			if (math.any(normal)) {
				SolidPlane(center, Quaternion.LookRotation(calculateTangent(normal), normal), size);
			}
			PopColor();
		}

		/// <summary>\copydocref{SolidPlane(float3,quaternion,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidPlane (float3 center, quaternion rotation, float2 size, Color color) {
			PushMatrix(float4x4.TRS(center, rotation, new float3(size.x, 0, size.y)));
			Reserve<Color32, BoxData>();
			Add(Command.Box | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new BoxData { center = 0, size = 1 });
			PopMatrix();
		}

		/// <summary>\copydocref{WirePlane(float3,float3,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void WirePlane (float3 center, float3 normal, float2 size, Color color) {
			PushColor(color);
			if (math.any(normal)) {
				WirePlane(center, Quaternion.LookRotation(calculateTangent(normal), normal), size);
			}
			PopColor();
		}
		/// <summary>\copydocref{WirePlane(float3,quaternion,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void WirePlane (float3 center, quaternion rotation, float2 size, Color color) {
			Reserve<Color32, PlaneData>();
			Add(Command.WirePlane | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new PlaneData { center = center, rotation = rotation, size = size });
		}
		/// <summary>\copydocref{PlaneWithNormal(float3,float3,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void PlaneWithNormal (float3 center, float3 normal, float2 size, Color color) {
			PushColor(color);
			if (math.any(normal)) {
				PlaneWithNormal(center, Quaternion.LookRotation(calculateTangent(normal), normal), size);
			}
			PopColor();
		}

		/// <summary>\copydocref{PlaneWithNormal(float3,quaternion,float2)}</summary>
		/// <param name="color">Color of the object</param>
		public void PlaneWithNormal (float3 center, quaternion rotation, float2 size, Color color) {
			PushColor(color);
			SolidPlane(center, rotation, size);
			WirePlane(center, rotation, size);
			ArrowRelativeSizeHead(center, center + math.mul(rotation, new float3(0, 1, 0)) * 0.5f, math.mul(rotation, new float3(0, 0, 1)), 0.2f);
			PopColor();
		}

		/// <summary>\copydocref{SolidTriangle(float3,float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidTriangle (float3 a, float3 b, float3 c, Color color) {
			Reserve<Color32, TriangleData>();
			Add(Command.SolidTriangle | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new TriangleData { a = a, b = b, c = c });
		}

		/// <summary>\copydocref{SolidBox(float3,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidBox (float3 center, float3 size, Color color) {
			Reserve<Color32, BoxData>();
			Add(Command.Box | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new BoxData { center = center, size = size });
		}
		/// <summary>\copydocref{SolidBox(Bounds)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidBox (Bounds bounds, Color color) {
			SolidBox(bounds.center, bounds.size, color);
		}
		/// <summary>\copydocref{SolidBox(float3,quaternion,float3)}</summary>
		/// <param name="color">Color of the object</param>
		public void SolidBox (float3 center, quaternion rotation, float3 size, Color color) {
			PushColor(color);
			PushMatrix(float4x4.TRS(center, rotation, size));
			SolidBox(float3.zero, Vector3.one);
			PopMatrix();
			PopColor();
		}
		/// <summary>\copydocref{Label3D(float3,quaternion,string,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label3D (float3 position, quaternion rotation, string text, float size, Color color) {
			Label3D(position, rotation, text, size, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,string,float,LabelAlignment)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label3D (float3 position, quaternion rotation, string text, float size, LabelAlignment alignment, Color color) {
			AssertBufferExists();
			var g = gizmos.Target as DrawingData;
			Reserve<Color32, TextData3D>();
			Add(Command.Text3D | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new TextData3D { center = position, rotation = rotation, numCharacters = text.Length, size = size, alignment = alignment });

			Reserve(UnsafeUtility.SizeOf<System.UInt16>() * text.Length);
			for (int i = 0; i < text.Length; i++) {
				char c = text[i];
				System.UInt16 index = (System.UInt16)g.fontData.GetIndex(c);
				Add(index);
			}
		}

		/// <summary>\copydocref{Label2D(float3,string,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, string text, float sizeInPixels, Color color) {
			Label2D(position, text, sizeInPixels, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label2D(float3,string,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, string text, Color color) {
			Label2D(position, text, 14, color);
		}

		/// <summary>\copydocref{Label2D(float3,string,float,LabelAlignment)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, string text, float sizeInPixels, LabelAlignment alignment, Color color) {
			AssertBufferExists();
			var g = gizmos.Target as DrawingData;
			Reserve<Color32, TextData>();
			Add(Command.Text | Command.PushColorInline);
			Add(ConvertColor(color));
			Add(new TextData { center = position, numCharacters = text.Length, sizeInPixels = sizeInPixels, alignment = alignment });

			Reserve(UnsafeUtility.SizeOf<System.UInt16>() * text.Length);
			for (int i = 0; i < text.Length; i++) {
				char c = text[i];
				System.UInt16 index = (System.UInt16)g.fontData.GetIndex(c);
				Add(index);
			}
		}

		/// <summary>\copydocref{Label2D(float3,FixedString32Bytes,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, ref FixedString32Bytes text, float sizeInPixels, Color color) {
			Label2D(position, ref text, sizeInPixels, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString32Bytes,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, ref FixedString32Bytes text, Color color) {
			Label2D(position, ref text, 14, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString64Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString64Bytes text, float sizeInPixels, Color color) {
			Label2D(position, ref text, sizeInPixels, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString64Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString64Bytes text, Color color) {
			Label2D(position, ref text, 14, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString128Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString128Bytes text, float sizeInPixels, Color color) {
			Label2D(position, ref text, sizeInPixels, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString128Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString128Bytes text, Color color) {
			Label2D(position, ref text, 14, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString512Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString512Bytes text, float sizeInPixels, Color color) {
			Label2D(position, ref text, sizeInPixels, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString512Bytes,float)}</summary>
		public void Label2D (float3 position, ref FixedString512Bytes text, Color color) {
			Label2D(position, ref text, 14, color);
		}

		/// <summary>\copydocref{Label2D(float3,FixedString32Bytes,float,LabelAlignment)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label2D (float3 position, ref FixedString32Bytes text, float sizeInPixels, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label2D(position, text.GetUnsafePtr(), text.Length, sizeInPixels, alignment);
			}
#else
			Debug.LogError("The Label2D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label2D(float3,FixedString64Bytes,float,LabelAlignment)}</summary>
		public void Label2D (float3 position, ref FixedString64Bytes text, float sizeInPixels, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label2D(position, text.GetUnsafePtr(), text.Length, sizeInPixels, alignment);
			}
#else
			Debug.LogError("The Label2D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label2D(float3,FixedString128Bytes,float,LabelAlignment)}</summary>
		public void Label2D (float3 position, ref FixedString128Bytes text, float sizeInPixels, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label2D(position, text.GetUnsafePtr(), text.Length, sizeInPixels, alignment);
			}
#else
			Debug.LogError("The Label2D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label2D(float3,FixedString512Bytes,float,LabelAlignment)}</summary>
		public void Label2D (float3 position, ref FixedString512Bytes text, float sizeInPixels, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label2D(position, text.GetUnsafePtr(), text.Length, sizeInPixels, alignment);
			}
#else
			Debug.LogError("The Label2D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString32Bytes,float)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label3D (float3 position, quaternion rotation, ref FixedString32Bytes text, float size, Color color) {
			Label3D(position, rotation, ref text, size, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString64Bytes,float)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString64Bytes text, float size, Color color) {
			Label3D(position, rotation, ref text, size, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString128Bytes,float)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString128Bytes text, float size, Color color) {
			Label3D(position, rotation, ref text, size, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString512Bytes,float)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString512Bytes text, float size, Color color) {
			Label3D(position, rotation, ref text, size, LabelAlignment.MiddleLeft, color);
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString32Bytes,float,LabelAlignment)}</summary>
		/// <param name="color">Color of the object</param>
		public void Label3D (float3 position, quaternion rotation, ref FixedString32Bytes text, float size, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label3D(position, rotation, text.GetUnsafePtr(), text.Length, size, alignment);
			}
#else
			Debug.LogError("The Label3D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString64Bytes,float,LabelAlignment)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString64Bytes text, float size, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label3D(position, rotation, text.GetUnsafePtr(), text.Length, size, alignment);
			}
#else
			Debug.LogError("The Label3D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString128Bytes,float,LabelAlignment)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString128Bytes text, float size, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label3D(position, rotation, text.GetUnsafePtr(), text.Length, size, alignment);
			}
#else
			Debug.LogError("The Label3D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}

		/// <summary>\copydocref{Label3D(float3,quaternion,FixedString512Bytes,float,LabelAlignment)}</summary>
		public void Label3D (float3 position, quaternion rotation, ref FixedString512Bytes text, float size, LabelAlignment alignment, Color color) {
			PushColor(color);
#if MODULE_COLLECTIONS_0_12_0_OR_NEWER
			unsafe {
				Label3D(position, rotation, text.GetUnsafePtr(), text.Length, size, alignment);
			}
#else
			Debug.LogError("The Label3D method which takes FixedStrings requires the Unity.Collections package version 0.12 or newer");
#endif
			PopColor();
		}
	}
}
