using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace MercuryMessaging.Protocol.DSL
{
    /// <summary>
    /// Fluent message builder for MercuryMessaging. This struct provides a chainable API
    /// for constructing and sending messages through the Mercury framework.
    /// Uses struct to avoid heap allocations and maintain high performance.
    /// </summary>
    public struct MmFluentMessage
    {
        private readonly MmRelayNode _relay;
        private readonly MmMethod _method;
        private readonly object _payload;
        private MmLevelFilter _levelFilter;
        private MmActiveFilter _activeFilter;
        private MmSelectedFilter _selectedFilter;
        private MmNetworkFilter _networkFilter;
        private MmTag _tag;
        private bool _hasCustomFilters;

        /// <summary>
        /// Initializes a new fluent message builder.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage(MmRelayNode relay, MmMethod method, object payload = null)
        {
            _relay = relay ?? throw new ArgumentNullException(nameof(relay));
            _method = method;
            _payload = payload;

            // Default values matching MmMetadataBlock defaults
            _levelFilter = MmLevelFilterHelper.SelfAndChildren;
            _activeFilter = MmActiveFilter.All;
            _selectedFilter = MmSelectedFilter.All;
            _networkFilter = MmNetworkFilter.Local;
            _tag = MmTagHelper.Everything;
            _hasCustomFilters = false;
        }

        #region Routing Methods

        /// <summary>
        /// Target child nodes in the hierarchy.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage To(MmLevelFilter filter)
        {
            _levelFilter = filter;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target only child nodes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToChildren()
        {
            _levelFilter = MmLevelFilter.Child;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target only parent nodes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToParents()
        {
            _levelFilter = MmLevelFilter.Parent;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target sibling nodes (same parent).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToSiblings()
        {
            _levelFilter = MmLevelFilter.Siblings;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target all descendants recursively.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToDescendants()
        {
            _levelFilter = MmLevelFilter.Descendants;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target all ancestors recursively.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToAncestors()
        {
            _levelFilter = MmLevelFilter.Ancestors;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target all connected nodes (bidirectional).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage ToAll()
        {
            _levelFilter = MmLevelFilterHelper.SelfAndBidirectional;
            _hasCustomFilters = true;
            return this;
        }

        #endregion

        #region Active Filter Methods

        /// <summary>
        /// Target only active GameObjects.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage Active()
        {
            _activeFilter = MmActiveFilter.Active;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Include inactive GameObjects.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage IncludeInactive()
        {
            _activeFilter = MmActiveFilter.All;
            _hasCustomFilters = true;
            return this;
        }

        #endregion

        #region Selected Filter Methods

        /// <summary>
        /// Target only FSM-selected responders.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage Selected()
        {
            _selectedFilter = MmSelectedFilter.Selected;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Target all responders regardless of selection.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage AllSelected()
        {
            _selectedFilter = MmSelectedFilter.All;
            _hasCustomFilters = true;
            return this;
        }

        #endregion

        #region Network Filter Methods

        /// <summary>
        /// Send message locally only.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage LocalOnly()
        {
            _networkFilter = MmNetworkFilter.Local;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Send message over network only.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage NetworkOnly()
        {
            _networkFilter = MmNetworkFilter.Network;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Send message both locally and over network.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage AllDestinations()
        {
            _networkFilter = MmNetworkFilter.All;
            _hasCustomFilters = true;
            return this;
        }

        #endregion

        #region Tag Methods

        /// <summary>
        /// Filter by a specific tag.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage WithTag(MmTag tag)
        {
            _tag = tag;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Filter by multiple tags (bitwise OR).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage WithTags(params MmTag[] tags)
        {
            MmTag combined = MmTagHelper.Nothing;
            foreach (var tag in tags)
            {
                combined |= tag;
            }
            _tag = combined;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Match any tag (no filtering).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage AnyTag()
        {
            _tag = MmTagHelper.Everything;
            _hasCustomFilters = true;
            return this;
        }

        /// <summary>
        /// Match no tags.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public MmFluentMessage NoTags()
        {
            _tag = MmTagHelper.Nothing;
            _hasCustomFilters = true;
            return this;
        }

        #endregion

        #region Execution Methods

        /// <summary>
        /// Execute the message send operation.
        /// This is the terminal operation that actually sends the message.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Execute()
        {
            if (_relay == null)
            {
                Debug.LogError("MmFluentMessage: Cannot execute without a relay node");
                return;
            }

            // Build metadata block
            MmMetadataBlock metadata;
            if (_hasCustomFilters)
            {
                // Use the constructor with tag as first parameter if tag is not Everything
                if (_tag != MmTagHelper.Everything)
                {
                    metadata = new MmMetadataBlock(_tag, _levelFilter, _activeFilter, _selectedFilter, _networkFilter);
                }
                else
                {
                    metadata = new MmMetadataBlock(_levelFilter, _activeFilter, _selectedFilter, _networkFilter);
                }
            }
            else
            {
                // Use default values - no tag parameter needed
                metadata = new MmMetadataBlock();
            }

            // Call appropriate MmInvoke based on method and payload
            switch (_method)
            {
                case MmMethod.Initialize:
                case MmMethod.Refresh:
                case MmMethod.Complete:
                case MmMethod.NoOp:
                    _relay.MmInvoke(_method, metadata);
                    break;

                case MmMethod.SetActive:
                case MmMethod.MessageBool:
                    if (_payload is bool boolValue)
                        _relay.MmInvoke(_method, boolValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected bool payload for {_method}");
                    break;

                case MmMethod.Switch:
                    if (_payload is string switchName)
                        _relay.MmInvoke(_method, switchName, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected string payload for {_method}");
                    break;

                case MmMethod.MessageInt:
                    if (_payload is int intValue)
                        _relay.MmInvoke(_method, intValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected int payload for {_method}");
                    break;

                case MmMethod.MessageFloat:
                    if (_payload is float floatValue)
                        _relay.MmInvoke(_method, floatValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected float payload for {_method}");
                    break;

                case MmMethod.MessageString:
                    if (_payload is string stringValue)
                        _relay.MmInvoke(_method, stringValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected string payload for {_method}");
                    break;

                case MmMethod.MessageVector3:
                    if (_payload is Vector3 vector3Value)
                        _relay.MmInvoke(_method, vector3Value, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected Vector3 payload for {_method}");
                    break;

                case MmMethod.MessageVector4:
                    if (_payload is Vector4 vector4Value)
                        _relay.MmInvoke(_method, vector4Value, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected Vector4 payload for {_method}");
                    break;

                case MmMethod.MessageQuaternion:
                    if (_payload is Quaternion quaternionValue)
                        _relay.MmInvoke(_method, quaternionValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected Quaternion payload for {_method}");
                    break;

                case MmMethod.MessageTransform:
                    if (_payload is Transform transformValue)
                        _relay.MmInvoke(_method, transformValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected Transform payload for {_method}");
                    break;

                case MmMethod.MessageGameObject:
                    if (_payload is GameObject gameObjectValue)
                        _relay.MmInvoke(_method, gameObjectValue, metadata);
                    else
                        Debug.LogError($"MmFluentMessage: Expected GameObject payload for {_method}");
                    break;

                default:
                    // Custom method - try to cast to MmMessage
                    if (_payload is MmMessage message)
                    {
                        message.MetadataBlock = metadata;
                        _relay.MmInvoke(message);
                    }
                    else
                    {
                        Debug.LogError($"MmFluentMessage: Unsupported method {_method} or invalid payload");
                    }
                    break;
            }
        }

        /// <summary>
        /// Alias for Execute() to provide alternative syntax.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Send()
        {
            Execute();
        }

        #endregion
    }
}